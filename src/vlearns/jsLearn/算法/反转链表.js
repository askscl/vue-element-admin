/**
 * 反转链表（单链表）
 * 
 *         1 =》2 =》3 =》4 =》5 =》 null
 * null《= 1《= 2《= 3《= 4《= 5
 * 
 * 解题思路：
 * 遍历，改变每个节点的next
 * 设置一个前指针pre和推进指针cur,推进直到cur为空、pre指向最后一个节点，  返回pre
 * 1.通过双指针遍历-------prev指针指向已经反转的部分，curr指针用于遍历未反转部分
 * 
 * 思考：
    * 1.为什么最后要返回pre-----返回的链表的头
    * 2. while的条件为什么是cur---当前节点为空时，结束遍历
    * 3.无法理解为啥这么换--根据示意图，已理解
    * 4.时间复杂度是：O(n)
    * 5.空间复杂度是：O(1)---为什么是1而不是 2，3？
    * 原因：
    * 当我们谈论空间复杂度时，我们关注的是算法在执行过程中所需的最大空间。在这个情况下，虽然我们使用了三个指针，但是这些指针都是用来进行链表反转的操作，而这个操作的空间需求是固定的。
    * 具体来说，这三个指针（prev、curr和next）都是用来跟踪链表节点的，它们在链表反转的过程中是必需的。但是，无论链表的长度如何，这三个指针的空间需求都是固定的，不会随着输入规模的增长而增长。因此，空间复杂度仍然是O(1)。
    * 我们不能简单地把这三个指针的空间需求加在一起得到O(3)，因为这样忽略了它们之间相互关系以及在算法中的共同作用。在计算空间复杂度时，我们应该考虑算法所需的最大空间，而不仅仅是单独考虑每个指针的空间需求。
    * 5.1这个操作的空间需求是固定的
    * 5.2不会随着输入规模的增长而增长。
    * 5.3考虑算法所需的最大空间，而不仅仅是单独考虑每个指针的空间需求
 */

//双指针遍历方法
function reverseList(head){
    let pre = null;
    let cur = head;
    while(cur){
        //第1步，先把1的next设为默认值 的null
        const temp = cur.next;
        cur.next = pre; 
        
        //第2步，移动双指针
        pre = cur;
        cur = temp;       
    }
    return pre;
}



//递归方法--（尾递归法）
/* 
时间复杂度为O(n), 空间复杂度为O(1);
*/
function reverseLink(head){
    if(head == null || head.next == null){
        return head
    }
    //拿到下一个节点，开始递归，最终找到最后一个节点
    const lastNode = reverseLink(head.next);

    //每轮递归的参数，拿来改变指向，-------注意不能写成cur,用2个数验证
    //倒数第二个开始
    head.next.next = head;
    head.next = null;

    return lastNode;


}